param(
    [string]$DriveLetter,
    [string]$MainFolderNames,
    [string]$SubFolderPatterns,
    [string]$CsvOutputPath
)

# The base path suffix is hardcoded here, except for the drive letter
$basePathSuffix = "\Your\Hardcoded\Path\After\DriveLetter"

# Construct the full base path by combining the user input drive letter with the hardcoded suffix
$basePath = "${DriveLetter}:$basePathSuffix"

# Convert comma-separated main folder names and sub-folder patterns to arrays
$mainFoldersArray = $MainFolderNames -split ","
$subFoldersArray = $SubFolderPatterns -split ","

# Initialize an array to collect the results
$results = @()

foreach ($folderName in $mainFoldersArray) {
    $folderPath = Join-Path -Path $basePath -ChildPath $folderName.Trim()
    
    foreach ($subPattern in $subFoldersArray) {
        $subFolderPath = Join-Path -Path $folderPath -ChildPath $subPattern
        
        # Check if the sub-folder exists before proceeding
        if (Test-Path $subFolderPath) {
            # Gather all the relevant files based on the patterns
            $workbookFiles = Get-ChildItem -Path $subFolderPath -Recurse -File | Where-Object { $_.Name -like '*workbook*.xlsx' -or $_.Name -like '*workbook*.xls' }
            $clearanceFiles = Get-ChildItem -Path $subFolderPath -Recurse -File | Where-Object { $_.Name -like '*clear*.msg' }
            $evidenceFiles = Get-ChildItem -Path $subFolderPath -Recurse -File | Where-Object { $_.Name -like '*evidence*document*.xlsx' -or $_.Name -like '*evidence*document*.xls' }

            # Join filenames into comma-separated strings
            $workbooks = $workbookFiles -join ", "
            $clearance = $clearanceFiles -join ", "
            $evidence = $evidenceFiles -join ", "

            # Check for empty results and set to "NO FILES FOUND" if none
            $workbooks = if ($workbooks) { $workbooks } else { "NO FILES FOUND" }
            $clearance = if ($clearance) { $clearance } else { "NO FILES FOUND" }
            $evidence = if ($evidence) { $evidence } else { "NO FILES FOUND" }

            $results += [PSCustomObject]@{
                MainFolder = $folderName
                SubFolder = $subPattern
                WorkbookFiles = $workbooks
                ClearanceFile = $clearance
                EvidenceDocumentFile = $evidence
            }
        }
    }
}

# Export the results to a CSV file
$results | Export-Csv -Path $CsvOutputPath -NoTypeInformation -Encoding UTF8






Sub ImportCsvData(csvFilePath As String)
    Dim ws As Worksheet
    Dim qt As QueryTable
    Dim sheetName As String
    Dim answer As VbMsgBoxResult
    
    ' Desired sheet name
    sheetName = "PowerShell Results"
    
    ' Check if the sheet already exists
    On Error Resume Next ' Ignore errors in the next statement
    Set ws = ThisWorkbook.Sheets(sheetName)
    On Error GoTo 0 ' Stop ignoring errors
    
    ' If the sheet exists, ask for confirmation to delete it
    If Not ws Is Nothing Then
        answer = MsgBox("A sheet named '" & sheetName & "' already exists. Do you want to replace it?", vbYesNo + vbQuestion, "Sheet Exists")
        If answer = vbYes Then
            Application.DisplayAlerts = False ' Turn off confirmation dialog for deleting
            ws.Delete
            Application.DisplayAlerts = True ' Turn back on system alerts
        Else
            MsgBox "Operation cancelled by user.", vbExclamation
            Exit Sub
        End If
    End If
    
    ' Create a new worksheet with the specified name
    Set ws = ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count))
    ws.Name = sheetName
    
    ' Import the CSV data
    Set qt = ws.QueryTables.Add(Connection:="TEXT;" & csvFilePath, Destination:=ws.Range("A1"))
    With qt
        .TextFileParseType = xlDelimited
        .TextFileCommaDelimiter = True
        .Refresh
    End With
    
    ' Loop to apply formatting if "NO FILES FOUND" (The loop remains as previously explained)
    
    ' Notify the user
    MsgBox "All done! Results have been imported and formatted into '" & ws.Name & "'.", vbInformation
End Sub

