param(
    [string]$DriveLetter,
    [string]$MainFolderNames,
    [string]$SubFolderPatterns,
    [string]$CsvOutputPath
)

# Hardcoded path component after the drive letter
$basePathSuffix = "\Your\Hardcoded\Path\After\DriveLetter"

# Construct the base path
$basePath = "${DriveLetter}:$basePathSuffix"

# Convert the comma-separated strings into arrays
$mainFoldersArray = $MainFolderNames -split ","
$subFoldersArray = $SubFolderPatterns -split ","

# Prepare an array to collect the results
$results = @()

foreach ($folderName in $mainFoldersArray) {
    $folderPath = Join-Path -Path $basePath -ChildPath $folderName.Trim()
    if (Test-Path $folderPath) {
        foreach ($subPattern in $subFoldersArray) {
            $subFolders = Get-ChildItem -Path $folderPath -Directory | Where-Object { $_.Name -like "*$subPattern*" }
            foreach ($subFolder in $subFolders) {
                # Process files within sub-folder as per your requirements
                $files = Get-ChildItem -Path $subFolder.FullName -File | Where-Object { $_.Name -like "*workbook*.xlsx" -or $_.Name -like "*evidence*.docx" }
                foreach ($file in $files) {
                    $results += [PSCustomObject]@{
                        MainFolder = $folderName
                        SubFolder = $subFolder.Name
                        FilePath = $file.FullName
                    }
                }
            }
        }
    }
}

# Export the results to CSV
$results | Export-Csv -Path $CsvOutputPath -NoTypeInformation -Encoding UTF8







Sub CallPowerShellAndImportData()
    Dim psScriptPath As String
    Dim csvOutputPath As String
    Dim shell As Object
    Dim command As String
    Dim driveLetter As String, mainFolders As String, subFolders As String
    
    ' Specify the path to your PowerShell script
    psScriptPath = "C:\Path\To\YourScript.ps1"
    
    ' Output path for the CSV file
    csvOutputPath = Environ("TEMP") & "\output.csv"
    
    ' Collect input from the user
    driveLetter = InputBox("Enter the drive letter (e.g., C, D, E):", "Drive Letter")
    mainFolders = InputBox("Enter main folder names (comma-separated):", "Main Folders")
    subFolders = InputBox("Enter sub-folder patterns (comma-separated):", "Sub Folders")
    
    ' Prepare the command to run the PowerShell script
    command = "powershell -ExecutionPolicy Bypass -File """ & psScriptPath & """ " & _
              """" & driveLetter & """ """ & mainFolders & """ """ & subFolders & """ """ & csvOutputPath & """"
    
    ' Create and run the command
    Set shell = CreateObject("WScript.Shell")
    shell.Run command, 0, True
    
    ' Wait for the PowerShell script to complete
    Application.Wait (Now + TimeValue("0:00:05")) ' Adjust time as necessary
    
    ' Import the CSV data into a new worksheet and apply formatting
    ImportCsvData csvOutputPath
End Sub

Sub ImportCsvData(csvFilePath As String)
    Dim ws As Worksheet
    Dim qt As QueryTable
    Dim lastRow As Long, i As Long
    Dim cell As Range
    
    ' Add a new worksheet
    Set ws = ThisWorkbook.Sheets.Add
    ws.Name = "PowerShell Results"
    
    ' Import the CSV data
    Set qt = ws.QueryTables.Add(Connection:="TEXT;" & csvFilePath, Destination:=ws.Range("A1"))
    With qt
        .TextFileParseType = xlDelimited
        .TextFileCommaDelimiter = True
        .Refresh
    End With
    
    ' Find the last row with data
    lastRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    
    ' Loop through each row, check specific columns, and format "NO FILES FOUND" cells
    For i = 2 To lastRow ' Assuming the first row has headers
        For Each cell In ws.Range("C" & i & ":E" & i)
            If cell.Value = "NO FILES FOUND" Then
                cell.Interior.Color = RGB(255, 0, 0) ' Apply red coloring
            End If
        Next cell
    Next i
    
    ' Notify the user
    MsgBox "All done! Results have been imported and formatted.", vbInformation
End Sub
